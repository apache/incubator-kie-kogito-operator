@Library('jenkins-pipeline-shared-libraries')_

IMAGES = ['kogito-operator']

helper = null

pipeline {
    agent {
        label 'rhel8 && podman && !built-in'
    }

    options {
        timeout(time: 120, unit: 'MINUTES')
    }

    environment {
        KOGITO_CI_EMAIL_TO = credentials("${JENKINS_EMAIL_CREDS_ID}")

        CONTAINER_ENGINE = 'podman'
        CONTAINER_ENGINE_TLS_OPTIONS = '--tls-verify=false'

        PR_BRANCH_HASH = "${util.generateHash(10)}"
        GITHUB_REPO = "${REPO_NAME}" // for github-release cli
    }

    stages {
        stage('Setup pipeline') {
            steps {
                script {
                    helper = load '.ci/jenkins/scripts/helper.groovy'
                    helper.initPipeline()
                }
            }
        }
        stage('Initialize') {
            steps {
                script {
                    helper.cleanGoPath()

                    helper.updateDisplayName()

                    properties.readFromUrl(helper.getDeployPropertiesFileUrl())

                    assert helper.getProjectVersion()
                    assert helper.getBuildBranch() == util.getReleaseBranchFromVersion(helper.getProjectVersion())

                    cloud.installSkopeo()
                }
            }
        }
        stage('Promote images') {
            steps {
                script {
                    helper.loginRegistry(baseImageParamsPrefix)
                    helper.loginRegistry(promoteImageParamsPrefix)

                    for (String imageName : getImages()) {
                        String imageTag = helper.getImageFullTag(imageName, baseImageParamsPrefix)
                        helper.promoteImage(imageTag, helper.getImageFullTag(imageName, promoteImageParamsPrefix))
                        if (helper.isDeployLatestTag()) {
                            helper.promoteImage(imageTag, helper.getImageFullTag(imageName, promoteImageParamsPrefix, 'latest'))
                        }
                        String reducedTag = getReducedTag()
                        if (reducedTag) {
                            helper.promoteImage(imageTag, helper.getImageFullTag(imageName, promoteImageParamsPrefix, reducedTag))
                        }
                    }
                }
            }
        }

        stage('Make Quay images public') {
            when {
                expression { helper.isQuayRegistry(promoteImageParamsPrefix) }
            }
            steps {
                script {
                    for (String imageName : getImages()) {
                        helper.makeQuayImagePublic(helper.getFullImageName(imageName, promoteImageParamsPrefix), promoteImageParamsPrefix)
                    }
                }
            }
        }

        stage('Merge PR, tag and release CLI') {
            steps {
                script {
                    dir(helper.getRepoName()) {
                        helper.checkoutRepo()

                        // Merge PR
                        String prLink = properties.retrieve("${helper.getRepoName()}.pr.link")
                        if (prLink) {
                            githubscm.mergePR(prLink, helper.getGitAuthorCredsID())
                            githubscm.pushObject('origin', helper.getBuildBranch(), helper.getGitAuthorCredsID())
                        }
                    }
                }
            }
        }

        stage('Create release') {
            steps {
                script {
                    if (githubscm.isReleaseExist(getGitTag(), getGitAuthorCredsID())) {
                        githubscm.deleteReleaseAndTag(getGitTag(), getGitAuthorCredsID())
                    }
                    githubscm.createReleaseWithGeneratedReleaseNotes(getGitTag(), getBuildBranch(), githubscm.getPreviousTag(getGitTag()), getGitAuthorCredsID())
                    githubscm.updateReleaseBody(getGitTag(), getGitAuthorCredsID())

                    sh "make build-cli release=true version=${getProjectVersion()}"
                    def releasePath = 'build/_output/release/'
                    def cliBaseName = "kogito-cli-${getProjectVersion()}"
                    def darwinFileName = "${cliBaseName}-darwin-amd64.tar.gz"
                    def linuxFileName = "${cliBaseName}-linux-amd64.tar.gz"
                    def windowsFileName = "${cliBaseName}-windows-amd64.zip"
                    def yamlInstaller = 'kogito-operator.yaml'
                    withCredentials([usernamePassword(credentialsId: getGitAuthorCredsID(), usernameVariable: 'GH_USER', passwordVariable: 'GH_TOKEN')]) {
                        sh """
                            gh release upload ${getGitTag()} "${releasePath}${darwinFileName}"
                            gh release upload ${getGitTag()} "${releasePath}${linuxFileName}"
                            gh release upload ${getGitTag()} "${releasePath}${windowsFileName}"
                            gh release upload ${getGitTag()} "${yamlInstaller}"
                        """
                    }
                }
            }
        }
    }
    post {
        unsuccessful {
            sendNotification()
        }
        cleanup {
            script {
                helper.cleanGoPath()
                util.cleanNode(containerEngine)
            }
        }
    }
}

void sendNotification() {
    if (params.SEND_NOTIFICATION) {
        mailer.sendMarkdownTestSummaryNotification('Promote', "[${helper.getBuildBranch()}] Kogito Operator", [env.KOGITO_CI_EMAIL_TO])
    } else {
        echo 'No notification sent per configuration'
    }
}
