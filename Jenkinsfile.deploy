@Library('jenkins-pipeline-shared-libraries')_

helper = null

pipeline {
    agent {
        label 'crc' // TODO move label to job generation ?
    }

    // Needed for local build
    tools {
        jdk 'kie-jdk11'
        maven 'kie-maven-3.6.3'
    }

    options {
        timeout(time: 360, unit: 'MINUTES')
    }

    // parameters {
    // For parameters, check into .jenkins/dsl/jobs.groovy file
    // }

    environment {
        // Static env is defined into .jenkins/dsl/jobs.groovy file

        BOT_BRANCH_HASH = "${util.generateHash(10)}"

        // Environment required by OLM tests when run from process
        OP_TEST_CONTAINER_OPT = '-t'
        OP_TEST_DEBUG = 1
        OP_TEST_CONTAINER_TOOL = 'docker'

        CRC_ENABLED = true // TODO should be moved to job generation

        GOLANG_VERSION = '1.14.15'
        GOLANG_DIR = "/tmp/golang-bin/${GOLANG_VERSION}"
        GOROOT = "${GOLANG_DIR}/go"
        GOPATH = "${GOLANG_DIR}/gopath"
        GOENV = "${GOLANG_DIR}/goenv"
        GOCACHE = "${GOLANG_DIR}/gocache"

        CRC_API = 'https://api.crc.testing:6443/'

        MVN_VERSION = '3.6.3'
        MVN_DIR = "/tmp/maven-bin/${MVN_VERSION}"

        GRAALVM_VERSION = '21.1.0'
        GRAALVM_DIR = "/tmp/graalvm-bin/${MVN_VERSION}"
        JAVA_HOME = "${GRAALVM_DIR}/graalvm-ce-java11-${GRAALVM_VERSION}"

        PATH = "${HOME}/.local/bin:${GOROOT}/bin:${GOPATH}/bin:${MVN_DIR}/apache-maven-${MVN_VERSION}/bin:${JAVA_HOME}/bin:${PATH}"
    }

    stages {
        stage('Setup pipeline') {
            steps {
                script {
                    helper = load '.jenkins/scripts/helper.groovy'
                    helper.initPipeline()
                }
            }
        }
        stage('Initialize') {
            steps {
                script {
                    helper.updateDisplayName()
                    helper.checkoutRepo()

                    if (helper.isRelease() || helper.isCreatePr()) {
                        // Verify version is set and if on right release branch
                        assert helper.getProjectVersion()

                        if(helper.isRelease()){
                            assert helper.getBuildBranch() == util.getReleaseBranchFromVersion(helper.getProjectVersion())
                        }
                    }

                    // Verify we have the connectivity to Openshift
                    if (CRC_ENABLED) {
                        timeout(time: 30, unit: 'MINUTES') {
                            waitUntil {
                                boolean crcStarted = fileExists(file: "${HOME}/.crc_started")
                                echo "Checking availability of CRC... ${crcStarted ? 'OK' : 'KO'}"
                                return crcStarted
                            }
                        }
                    } else {
                        openshift.loginOpenshift()
                    }

                    // TODO temp solution
                    dir("${GRAALVM_DIR}") {
                        sh """
                            wget --no-verbose https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-${GRAALVM_VERSION}/graalvm-ce-java11-linux-amd64-${GRAALVM_VERSION}.tar.gz
                            tar xzvf graalvm-ce-java11-linux-amd64-${GRAALVM_VERSION}.tar.gz
                            java -version
                        """
                    }
                    dir("${MVN_DIR}") {
                        sh """
                            wget --no-verbose https://miroir.univ-lorraine.fr/apache/maven/maven-3/${MVN_VERSION}/binaries/apache-maven-${MVN_VERSION}-bin.tar.gz
                            tar xzvf apache-maven-${MVN_VERSION}-bin.tar.gz
                            mvn --version
                        """
                    }
                    // END Temp solution

                    sh '''
                        source /home/hudson/cekit/bin/activate
                        cekit --help
                        pip3 install -U ansible
                        ansible --version
                    '''

                    // Install golang
                    dir("${GOLANG_DIR}") {
                        sh """
                            wget --no-verbose https://golang.org/dl/go${GOLANG_VERSION}.linux-amd64.tar.gz
                            tar -xzf go${GOLANG_VERSION}.linux-amd64.tar.gz
                            go version
                        """
                    }
                }
            }
            post {
                success {
                    script {
                        properties.add('git.branch', helper.getBuildBranch())
                        properties.add('git.author', helper.getGitAuthor())
                        properties.add('project.version', helper.getProjectVersion())
                        properties.add('release', helper.isRelease())
                    }
                }
            }
        }

        stage('Prepare for PR') {
            when {
                expression { return helper.isRelease() || helper.isCreatePr() }
            }
            steps {
                script {
                    githubscm.forkRepo(helper.getBotAuthorCredsID())
                    githubscm.createBranch(helper.getBotBranch())
                }
            }
        }

        stage('Update version') {
            when {
                expression { return helper.getProjectVersion() }
            }
            steps {
                script {
                    sh "make bump-version new_version=${helper.getProjectVersion()}"

                    githubscm.commitChanges("Update project version to ${helper.getProjectVersion()}", {
                        sh '''
                            git add .
                            git reset -- go.mod
                            git reset -- go.sum
                        '''
                    })
                }
            }
        }

        // stage('Test Kogito Operator & CLI') {
        //     when {
        //         expression {
        //             return helper.shouldLaunchTests()
        //         }
        //     }
        //     steps {
        //         sh 'make test'
        //     }
        // }

        stage('Build Kogito Operator') {
            steps {
                sh """
                    source /home/hudson/cekit/bin/activate
                    make BUILDER=${env.CONTAINER_ENGINE}
                """
            }
        }

        stage('Build Kogito CLI') {
            steps {
                sh 'make build-cli'
            }
            post {
                success {
                    script {
                        archiveArtifacts artifacts: 'build/_output/bin/kogito', allowEmptyArchive: false
                    }
                }
            }
        }

        // No docker on CRC node ... need it ?
        // stage('Run OLM tests') {
        //     when {
        //         expression {
        //             return helper.shouldLaunchTests()
        //         }
        //     }
        //     steps {
        //         sh '''
        //             source /home/hudson/cekit/bin/activate
        //             make olm-tests
        //         '''
        //     }
        // }

        stage('Push Operator Image to Openshift Registry') {
            steps {
                script {
                    container.loginOpenshiftRegistry()

                    container.tagImage("quay.io/kiegroup/${env.OPERATOR_IMAGE_NAME}:${getOperatorVersion()}", 
                                            helper.buildTempOpenshiftImageFullName())
                    container.pushImage(helper.buildTempOpenshiftImageFullName())
                }
            }
        }

        stage('Run BDD tests') {
            when {
                expression {
                    return helper.shouldLaunchTests()
                }
            }
            // TODO temp disable
            // options {
            //     // Lock on OCP API as we want only one run at a time
            //     lock("BDD tests on OCP API ${getLockOpenshiftApi()}")
            // }
            steps {
                script {
                    // Catch and set unstable so the temp image is still pushed and we get the deployment properties,
                    // in case we decide to continue in the release
                    try {
                        // Use docker because of https://issues.redhat.com/browse/KOGITO-3512
                        sh "make run-tests timeout=360 load_factor=1 concurrent=3 smoke=${params.SMOKE_TESTS_ONLY} ${getBDDParameters()}"
                    } catch (err) {
                        unstable('Tests are failing')
                    }
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'test/logs/**/*.log', allowEmptyArchive: true
                    junit testResults: 'test/logs/**/junit.xml', allowEmptyResults: true
                }
                cleanup {
                    sh 'cd test && go run scripts/prune_namespaces.go'
                }
            }
        }

        stage('Push to registry') {
            steps {
                script {
                    echo "$STAGE_NAME"
                    // helper.loginRegistry()

                    // container.tagImage(helper.buildTempOpenshiftImageFullName(), helper.getImageFullTag(env.OPERATOR_IMAGE_NAME))
                    // container.pushImage(helper.getImageFullTag(env.OPERATOR_IMAGE_NAME))

                    // // Store image deployment information
                    // properties.add(helper.getImageRegistryProperty(), helper.getImageRegistry())
                    // properties.add(helper.getImageNamespaceProperty(), helper.getImageNamespace())
                    // properties.add(helper.getImageNamePrefixProperty(), helper.getImageNamePrefix())
                    // properties.add(helper.getImageNameSuffixProperty(), helper.getImageNameSuffix())
                    // properties.add(helper.getImageTagProperty(), helper.getImageTag())
                }
            }
        }

        stage('Create PR') {
            when {
                expression { return helper.isRelease() || helper.isCreatePr() }
            }
            steps {
                script {
                    if (githubscm.isThereAnyChanges()) {
                        String prMsg = "[${helper.getBuildBranch()}] Update version to ${helper.getProjectVersion()}"
                        def prBody = "Generated by build ${BUILD_TAG}: ${BUILD_URL}.\nPlease do not merge, it shoud be merged automatically."
                        githubscm.pushObject('origin', helper.getBotBranch(), helper.getBotAuthorCredsID())
                        prLink = githubscm.createPR(prMsg, prBody, helper.getBuildBranch(), helper.getBotAuthorCredsID())
                        properties.add("${helper.getRepoName()}.pr.link", prLink)

                        properties.add("${helper.getRepoName()}.pr.source.uri", "https://github.com/${helper.getBotAuthor()}/${helper.getRepoName()}")
                        properties.add("${helper.getRepoName()}.pr.source.ref", helper.getBotBranch())
                        properties.add("${helper.getRepoName()}.pr.target.uri", "https://github.com/${helper.getGitAuthor()}/${helper.getRepoName()}")
                        properties.add("${helper.getRepoName()}.pr.target.ref", helper.getBuildBranch())
                    } else {
                        println '[WARN] no changes to commit'
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                properties.writeToFile(env.PROPERTIES_FILE_NAME)
                archiveArtifacts(artifacts: env.PROPERTIES_FILE_NAME)
            }
        }
        cleanup {
            script {
                util.cleanNode(containerEngine)
                sh "sudo rm -rf ${GOLANG_DIR}"
            }
        }
    }
}

String getOperatorVersion() {
    return sh(script: 'source ./hack/env.sh > /dev/null && echo $(getOperatorVersion)', returnStdout: true).trim()
}

// Special method to get the Openshift API in the lock because env is not accessible yet
void getLockOpenshiftApi() {
    if (env.CRC_ENABLED) {
        return env.CRC_API
    } else {
        withCredentials([string(credentialsId: 'OPENSHIFT_API', variable: 'OPENSHIFT_API')]) {
            return env.OPENSHIFT_API
        }
    }
}

////////////////////////////////////////////////////////////////////////
// BDD parameters

String getBDDParameters() {
    Map testParamsMap = helper.getBDDCommonParameters(true)

    testParamsMap.putAll(helper.getBDDBuildImageParameters('KOGITO_IMAGES'))
    testParamsMap.putAll(helper.getBDDServicesImageParameters('KOGITO_IMAGES'))

    testParamsMap['image_cache_mode'] = params.EXAMPLES_IMAGES_CACHE_MODE
    testParamsMap.putAll(helper.getBDDRuntimeImageParameters('EXAMPLES_IMAGES'))

    // Add tags
    def tags = []
    if (params.BDD_TEST_TAGS) {
        tags.add(params.BDD_TEST_TAGS)
    }
    if (params.SKIP_NATIVE_TESTS) {
        tags.add(helper.getNonNativeTag())
    }
    testParamsMap['tags'] = tags.join('&&')

    String testParams = testParamsMap.findAll { entry -> entry.getValue() }
                            .collect { entry -> "${entry.getKey()}=\"${entry.getValue()}\"" }.join(' ')
    echo "BDD parameters = ${testParams}"
    return testParams
}
